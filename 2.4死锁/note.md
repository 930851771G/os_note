2.4_1_死锁的概念
---

* gxy：
  掌握死锁概念。
  理解、区分死锁、饥饿、死循环。
  掌握死锁发生的必要条件：争夺互斥资源、进程不可剥夺、申请且保持、循环等待链。

![image-20240521145404458](img/image-20240521145404458.png)

* 死锁的概念：
  各个进程因为争夺资源而造成的一种`互相等待对方手里的资源`，导致各进程都阻塞，无法向前推进的现象。

  发生死锁之后，如果没有外力的干涉，这些进程都将无法向前推进。

* 死锁、饥饿、死循环区别：
  <img src="img/image-20240521145935229.png" alt="image-20240521145935229" style="zoom:67%;" />
  饥饿：长期得不到自己想要的资源，导致一直不能往前推进的状态。
  比如之前的short process first中，长进程很有可能会一直没有办法得到处理机资源，就会一直等待，就是饥饿。

  饥饿往往是 阻塞态或者就绪态
  而死循环可以是运行态，只不过是不会往下推进，其实一直在执行。

  死循环：往往是逻辑错误，或者是程序员故意如此设计。

* 死锁产生的必要条件：
  1.**互斥条件。**必须是进程对于互斥资源的争抢。
  2.**不剥夺条件。**进程获得的资源只能主动释放，不能被其他进程强行夺走。
  3.**请求和保持条件**。每一个进程至少保持一个资源，至少申请一个新的资源，又对自己已经有的资源保持不放。
  4.**循环等待条件。**一定有循环等待链。循环等待链是死锁的必要不充分条件。

* 什么时候会发生死锁：
  下面会提供一个例子。
  一句话总结就是`对不可剥夺资源的不合理分配就可能会导致死锁。`
  <img src="img/image-20240521150940590.png" alt="image-20240521150940590" style="zoom: 67%;" />

* 死锁处理策略：
  ![image-20240521151013625](img/image-20240521151013625.png)





死锁处理的大纲：
---

![image-20240521151429586](img/image-20240521151429586.png)

预防和避免都是从不允许死锁发生的角度。
死锁的检测和解除是允许死锁的发生的角度。

2.4_2_死锁处理策略--预防死锁
---

预防死锁的思路，就是看能不能破坏死锁产生的四个必要条件，只要破坏了至少一个，死锁就不会发生。

* gxy:
  这一节课的所有内容，理解即可，不需要会背。
  ![image-20240521153943280](img/image-20240521153943280.png)

* 破坏互斥条件：只有对互斥资源进行争夺才会产生死锁。

  比如在多个进程同时争夺打印机的使用权时，可以采用SPOOLing技术，可以把打印机这个独占设备改为共享设备。
  具体实现的细节时SPOOLing技术里面的输出进程接受了多个进程的打印机请求之后，自己内部进行处理并在最后输出。然后从进程的角度看，打印机的资源变为了共享设备，但只是从进程的角度看。

  这个方法的缺点：不是所有的互斥资源都可以更改为共享资源，而且出于系统安全的考虑，很多互斥条件时必须保持的，不能被破坏。

* 破坏不剥夺条件：进程中获得的资源在使用完毕之前，不能被其他进程强行夺走，只能自己主动释放。
  <img src="img/image-20240521153009609.png" alt="image-20240521153009609" style="zoom:67%;" />

* 破坏请求和保持条件：进程已经至少保持了一个资源，但是又提出了新的资源的请求，但是新的资源被其他进程等占用，所以自己进入阻塞状态，同时**保持自己原来的资源**不变。

  可以采用`静态分配方法`：进程在运行前一次申请完所有它需要的全部资源，只有得到全部资源之后才会进入运行，并且一旦运行之后，这些资源就一直属于这个进程。

  缺点：如果一个资源利用时间很短，进程运行时间长，这个资源就会一直闲置，导致这个资源的利用率低。有可能产生饥饿：有一种进程1需要资源1，进程2需要资源2，进程3需要1\2两个资源，在有很多进程1的情况下，进程3就一直不能得到自己需要的所有的资源，就会饥饿。

* 破坏循环等待链条件：
  <img src="img/image-20240521154030112.png" alt="image-20240521154030112" style="zoom:67%;" />

