3.1_1_内存的基础知识
---

这一部分，比较杂，比较碎，但是其实比较重要。之后再学习吧。
里面甚至讲解了有关 写程序到程序运行的过程中做了什么。



3.1_2_内存管理的概念
---

* gxy总结：
  **这一节不是很重要，知识对于内存要做什么形成一个框架。**
  <img src="img/image-20240522114150639.png" alt="image-20240522114150639" style="zoom:67%;" />

  这一节就围绕着 内存管理做了什么。
  内存空间的分配和回收
  从逻辑上对内存空间进行扩充。
  物理地址和逻辑地址的转换。==这一点之后学完3.1_1再把这里回顾一下==
  如何进行内存保护，让每一个进程只能访问自己的内存区域的数据。

OS作为系统资源的管理者，对于内存的管理要做些什么？
进程运行之前，进程相关数据要放到内存里面。内存中有的区域是空闲的，有的不是空闲的，操作系统要如何管理这些空闲、非空闲的区域？
以及一个数据要放到内存，但是有很多空闲的区域都可以放，到地方哪里？
进程运行结束之后，如何把进程占用的内存空间回收？

* 内存管理做什么：
  1.OS负责**内存空间的分配和回收**。
  2.OS提供某种技术从逻辑上**对内存空间进行扩充**。（比如说，一个游戏大小为60G，但是内存只有4G，运行的时候需要采用虚拟技术，可以把物理上很小的内存转换为逻辑上很大的内存）。
  3.OS应该提供**地址转换**的功能，负责程序的`逻辑地址`和`物理地址`的相互转换。
  <img src="img/image-20240522113213625.png" alt="image-20240522113213625" style="zoom:67%;" />
  4.内存保护：使得各个进程只能网文自己的内存区域，不能访问别的进程的。

  内存保护的方法：
  <1>。可以设置上下限寄存器，存储这个进程的内存空间占据的地址的起点和终点，访问指令的时候，首先检查是否越界。
  <2>。采用`重定位寄存器加界地址寄存器`进行越界检查。举一个例子，一个进程的内存地址是100~279，重定位寄存器放100，**界地址寄存器**放最大逻辑地址就是179。每一次要访问一个地址的时候，比如逻辑地址80，先和界地址寄存器进行比较，如果大于界地址寄存器的值，就是越界。**重定位寄存器又称为基址寄存器，界地址寄存器又称为限长寄存器。**
  <img src="img/image-20240522113807282.png" alt="image-20240522113807282" style="zoom:67%;" />





3.1_3_覆盖与交换
---

* gxy总结：
  这一节主要讲的是上面的 OS中内存管理做的事情中的内存的扩充。
  内存的扩充有三种方法：![image-20240522114438880](img/image-20240522114438880.png)
  这里讲了覆盖技术和交换技术。

  只需要理解覆盖技术和交换技术的思想即可。
  固定区域的程序 不会调入调出。覆盖区的程序段在运行中会根据需要进行调入调出。

* 覆盖技术：
  `思想：`将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段需要的时候调入内存。
  内存会分为一个`固定区`和若干个`覆盖区`。
  固定区在调入之后就不会调出，直到运行结束。
  覆盖区需要需要用到的时候调入内存，用不到的时候就会调出内存。

  举例：
   ![image-20240522120435287](img/image-20240522120435287.png)
  解释一下这个调用结构:
  A会调用BC模块，但是两个不会同时调用，然后B会调用D模块，C会调用EF模块，但是EF不会同时，最多只会一个被调用。

  就可以通过覆盖技术设计这样的内存：
  <img src="img/image-20240522120558166.png" alt="image-20240522120558166" style="zoom:67%;" />
  划分一个A的固定区域，然后BC放在同一个覆盖区域，DEF也放在一个覆盖区域。

  然后再运行的时候，如果BCDEF需要运行，会使用自己相应覆盖区内存位置的内存，用完之后就会调出内存。

  缺点：
  **必须由程序员声明覆盖结构**，OS完成自动覆盖。
  对用户不透明，增加了用户编程的复旦，覆盖技术只用于早期的OS中，已经成为历史。

* 交换技术思想：对换技术
  **内存空间紧张的时候，可系统将内存中一些进程暂时`换出`到外存，把外村当中已经具备运行条件的进程`换入`内存**。其实就是进程在磁盘和内存之间的动态调度。

  举例：中级调度、进程调度：在内存紧张的时候，可以选择内存中的进程进入挂起状态，(PCB还在内存里面，帮助之后恢复这个进程的状态)，内存空间充足的时候，再把挂起的进程换入内存。

  问题：
  ![image-20240522115715044](img/image-20240522115715044.png)

  回答：
  1.如果有对换功能的OS，磁盘会分为文件区域和兑换区域。
  文件区域：用来存放文件，追求空间利用率，应该用离散分配方式。
  对换区域：应该只占一小部分，被换出的进程就放在对换区。对换区应该追求换入换出速度，因此通常对换区`采用连续分配方式`。之后，对换区的I/O速度比文件区更快，也就是输入/输出速度。

  ![image-20240522120137512](img/image-20240522120137512.png)
  2.什么时候交换：
  ![image-20240522120035836](img/image-20240522120050544.png)
  ![image-20240522120124394](img/image-20240522120124394.png)



