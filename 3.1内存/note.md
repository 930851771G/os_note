3.1_1_内存的基础知
---

这一部分，比较杂，比较碎，但是其实比较重要。之后再学习吧。
里面甚至讲解了有关 写程序到程序运行的过程中做了什么。



3.1_2_内存管理的概念
---

* gxy总结：
  **这一节不是很重要，知识对于内存要做什么形成一个框架。**
  <img src="img/image-20240522114150639.png" alt="image-20240522114150639" style="zoom:67%;" />

  这一节就围绕着 内存管理做了什么。
  内存空间的分配和回收
  从逻辑上对内存空间进行扩充。
  物理地址和逻辑地址的转换。==这一点之后学完3.1_1再把这里回顾一下==
  如何进行内存保护，让每一个进程只能访问自己的内存区域的数据。

OS作为系统资源的管理者，对于内存的管理要做些什么？
进程运行之前，进程相关数据要放到内存里面。内存中有的区域是空闲的，有的不是空闲的，操作系统要如何管理这些空闲、非空闲的区域？
以及一个数据要放到内存，但是有很多空闲的区域都可以放，到地方哪里？
进程运行结束之后，如何把进程占用的内存空间回收？

* 内存管理做什么：
  1.OS负责**内存空间的分配和回收**。
  2.OS提供某种技术从逻辑上**对内存空间进行扩充**。（比如说，一个游戏大小为60G，但是内存只有4G，运行的时候需要采用虚拟技术，可以把物理上很小的内存转换为逻辑上很大的内存）。
  3.OS应该提供**地址转换**的功能，负责程序的`逻辑地址`和`物理地址`的相互转换。
  <img src="img/image-20240522113213625.png" alt="image-20240522113213625" style="zoom:67%;" />
  4.内存保护：使得各个进程只能网文自己的内存区域，不能访问别的进程的。

  内存保护的方法：
  <1>。可以设置上下限寄存器，存储这个进程的内存空间占据的地址的起点和终点，访问指令的时候，首先检查是否越界。
  <2>。采用`重定位寄存器加界地址寄存器`进行越界检查。举一个例子，一个进程的内存地址是100~279，重定位寄存器放100，**界地址寄存器**放最大逻辑地址就是179。每一次要访问一个地址的时候，比如逻辑地址80，先和界地址寄存器进行比较，如果大于界地址寄存器的值，就是越界。**重定位寄存器又称为基址寄存器，界地址寄存器又称为限长寄存器。**
  <img src="img/image-20240522113807282.png" alt="image-20240522113807282" style="zoom:67%;" />





3.1_3_覆盖与交换
---

* gxy总结：
  这一节主要讲的是上面的 OS中内存管理做的事情中的内存的扩充。
  内存的扩充有三种方法：![image-20240522114438880](img/image-20240522114438880.png)
  这里讲了覆盖技术和交换技术。

  只需要理解覆盖技术和交换技术的思想即可。
  固定区域的程序 不会调入调出。覆盖区的程序段在运行中会根据需要进行调入调出。

* 覆盖技术：
  `思想：`将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段需要的时候调入内存。
  内存会分为一个`固定区`和若干个`覆盖区`。
  固定区在调入之后就不会调出，直到运行结束。
  覆盖区需要需要用到的时候调入内存，用不到的时候就会调出内存。

  举例：
   ![image-20240522120435287](img/image-20240522120435287.png)
  解释一下这个调用结构:
  A会调用BC模块，但是两个不会同时调用，然后B会调用D模块，C会调用EF模块，但是EF不会同时，最多只会一个被调用。

  就可以通过覆盖技术设计这样的内存：
  <img src="img/image-20240522120558166.png" alt="image-20240522120558166" style="zoom:67%;" />
  划分一个A的固定区域，然后BC放在同一个覆盖区域，DEF也放在一个覆盖区域。

  然后再运行的时候，如果BCDEF需要运行，会使用自己相应覆盖区内存位置的内存，用完之后就会调出内存。

  缺点：
  **必须由程序员声明覆盖结构**，OS完成自动覆盖。
  对用户不透明，增加了用户编程的复旦，覆盖技术只用于早期的OS中，已经成为历史。

* 交换技术思想：对换技术
  **内存空间紧张的时候，可系统将内存中一些进程暂时`换出`到外存，把外村当中已经具备运行条件的进程`换入`内存**。其实就是进程在磁盘和内存之间的动态调度。

  举例：中级调度、进程调度：在内存紧张的时候，可以选择内存中的进程进入挂起状态，(PCB还在内存里面，帮助之后恢复这个进程的状态)，内存空间充足的时候，再把挂起的进程换入内存。

  问题：
  ![image-20240522115715044](img/image-20240522115715044.png)

  回答：
  1.如果有对换功能的OS，磁盘会分为文件区域和兑换区域。
  文件区域：用来存放文件，追求空间利用率，应该用离散分配方式。
  对换区域：应该只占一小部分，被换出的进程就放在对换区。对换区应该追求换入换出速度，因此通常对换区`采用连续分配方式`。之后，对换区的I/O速度比文件区更快，也就是输入/输出速度。

  ![image-20240522120137512](img/image-20240522120137512.png)
  2.什么时候交换：
  ![image-20240522120035836](img/image-20240522120050544.png)
  ![image-20240522120124394](img/image-20240522120124394.png)



3.1_4_连续分配管理方式
---

OS对内存的管理需要实现：逻辑地址和物理地址的转换，内控空间的扩充(覆盖技术 交换技术)，存储保护（设置上下限，使用重定位寄存架 + 界地址寄存器），内存空间的分配和回收。

会先介绍 连续分配管理方式，连续和非连续分配的区别在于：
**连续分配是指，为用户进程分配的必须是一个`连续的内存空间`**。
非连续内存分配：就是系统为用户分配的地址空间不一定是连续的，可以是离散的。

* 介绍一个在评估内存管理的性能的时候会提到的一个专业名词：
  **内部碎片**：分配给某进程的内存区域里面，有一些部分没有用上，就是“内部碎片”。
  **外部碎片：**

* 单一连续分配方式：(在单道程序环境下)
  会把内存分为：`系统区`（存放OS相关数据），`用户区`（存放用户进程相关数据）。
  单一连续分配方式：内存中只能有一道用户程序，用户程序占整个用户区的空间。
  优点：实现简单，没有外部碎片
  缺点：只能单用户、单任务的OS，有内部碎片。

* 固定分区分配：
  `思想：`将整个用户空间划分为`若干个固定大小的分区`，每一个分区中，最多装入一个作业。

  形成了最早的、最简单的可以运行多道程序的内存管理方式。

  <img src="img/image-20240523104418084.png" alt="image-20240523104418084" style="zoom:67%;" />

  * 分区大小相等：
    把用户空间，划分为若干个大小相等的分区。
    **缺点**：缺乏灵活性，程序小的时候，会产生很多内存碎片，程序大的时候又装不下。
    **优点：**可以应用于 一台计算机控制多个相同对象的场合。比如工厂中，一台计算机，控制100台炼丹炉，每一个炼丹炉的内存空间可以都划分为一样。

  * 分区大小不等：

    增加灵活性，可以满足不同大小的进程需求。一般都是根据常常运行的作业的大小情况来进行划分。


  操作系统如何实现在`固定分区分配方法`中的各个分区的分配与回收：
  建立一个数据结构--`分区说明表`。表里面包含每一个分区的起始地址、大小、当前状态。

  优点：实现简单，**没有外部碎片**。
  缺点：
  1.如果用户程序太大，所有分区都不满足，只能用覆盖技术，会降低性能。
  2.会产生**内存碎片**，内存利用率低。

* 动态分区分配：
  `思想：`可变分区分配，不会预先划分内存分区，而是在进程装入内存的时候，`根据进程的大小动态地建立分区`，使得分区的大小正好适合进程的需要。
  提出一些问题：

  * 用怎样的数据结构来记录内存的使用情况：
    使用空闲分区表、或者空闲分区链。
    每一项会记录空闲分区的开始地址、大小记录下来。而空闲分区表里面内容的排列顺序和使用那种动态分配算法有关系。

  * 有很多空闲分区的时候，选择哪个分区进行分配？
    下一节的动态分区分配算法回答这个问题。

  * 如何进行分区的分配和回收操作？

    分配是通过动态分区分配算法来选择的，分配完了之后要更改对应的空闲分区表/链，有可能知识原来的信息减小，也有可能是删除一项信息。

    回收操作：
    一句话总结就是
    **在进行内区回收之后，如果发现有一些空闲分区是相邻的，就要进行合并**。

* 内部碎片和外部碎片的概念：
  **内部碎片**：是指分配给进程的内存空间中没有被使用的内存。
  **外部碎片**：是指因为空间太小，难以利用的内存空间。（一般在动态分区分配的时候可能会遇到）。

  如果在动态分区分配中遇到内存空间综合满足要求，但是因为是分散的所以不能满足要求，可以通过**紧凑**技术来解决外部碎片。

* 动态分区分配算法：
  就是从空闲分区表、空闲分区链里面如何选出来一个分区分配给当前作业。

3.1_5_动态分区分配算法
---

* gxy总结：
  **之后复习的时候，可以找一下题目来理解**。
  
  **讲了四个算法**.
  理解算法思想，查询过程，理解优点和缺点。
  
  首次适应，每次都从头，开销大，容易留下外部碎片。最佳适应也是。
  最坏适应，大分区用完之后的大金程就没办法弄，开销也大。
  临近适应中，高地址的大分区有相同概率备用。
  
  优点：
  首次：综合看性能最好，开销小，回收分区后一般不需要重新排序。
  首次适应：会有很多大分区保存下来。
  最坏：减少外部碎片数目。
  邻近适应：开销很小。每一次都从最低开始找。
  
  有一个特点，四种算法都是查找的时候找到第一个满足要求的就可以了。
  
  ![image-20240524122353736](img/image-20240524122353736.png)
  
* 首次适应算法:
  `思想：`每次从低地址开始查找，找到第一个能够满足大小的空闲分区。

  可以让空闲分区按照地址递增的次序排列。每一次顺序查找空闲分区表、链，找到第一个大小能够满足要求的分区。

* 最佳适应算法：
  `思想：`将空闲分区按照`容量递增的次序链接`，每次分配内存时顺序查找空闲分区链、空闲分区表，找到大小能够满足要求的第一个空闲分区。
  （其实就是找到最小的能够满足要求的空闲分区）。

  `缺点：`每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。会产生很多外部碎片。

* 最坏适应算法：
  `思想：`为了解决最佳适应算法中留下太多难以利用的小碎片的问题，引入了最坏适应算法。
  `实现方式：`按照`容量递减`的次序链接。每一次分配内存时顺序查找`空闲分区链、表`，找到大小能够满足要求的第一个空闲分区。
  `缺点：`每次都选择最大的分区进行分配，解决了之前的可能留下很多外部碎片的问题，但是可能会导致较大的连续空间迅速用完，之后如果还有大进程，就没有内存分区可用了。

* 邻近适应算法：
  首次适应算法每一次都是从链头开始查找，可能导致低地址部分出现很多分区，每一次分配查找都要经过这些分区，增加开销。
  `思想：`首先把空闲分区按照地址递增的顺序排列，（可以是循环链表），之后每一次分配时`从上一次查找结束的位置开始`查找空闲分区，找到大小能够满足要求的第一个空闲分区。

  `优点：`算法开销比较小，不需要对分区表、分区链重新排列。同时每一次也不需要到最开始的位置查找。

* 首次适应算法和最佳适应算法：
  有一个优点是可能把高地址部分的大分区留下来。

  这个优点对于邻近适应算法：
  低地址、高地址部分的空闲分区都有相同的概率被使用，导致高地址部分的大分区容易被划分为小分区，最后容易导致没有小分区可以使用。这也是最大适应算法的缺点。



3.1_6_基本分页存储管理的概念
---

* gxy总结：
  是高频考点 + 难点。
